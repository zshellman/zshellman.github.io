---
layout: page
title: 高性能MySQL 第十章 复制
mermaid: false
---

# 第十章 复制

MySQL的主从复制主要是针对日志的读取。用来做主从复制，备份数据的。



复制解决的问题：

- 数据分布
- 负载均衡
- 备份
- 高可用性和故障切换
- MySQL升级测试



复制的步骤

- 在主库上把数据更改记录到二进制日志（Binary Log）中
- 备库将主库上的日志复制到自己的中继日志（Relay Log）中
- 备库读取中继日志中的事件，将其重放到备库的数据之上



为MySQL服务器配置复制：

- 1.在每台服务器上创建复制账号
- 2.配置主库和备库
- 3.通知备库连接到主库并从主库复制数据



## 复制的原理

基于语句的复制

> binlog_format=statement
>
> 简单理解就是binlog里记录的是执行sql语句，备库只要同样按照执行即可，同步很方便。
>
> 优点：容易理解，出问题更容易定位。
>
> 缺点：很多情况下无法正确复制，如果正在使用触发器或者存储过程，就不要使用基于语句的复制。



基于行的复制

> binlog_format=row
>
> 这种模式下MySQL日志中会记录成每一行数据被修改的形式，然后在 slave 端再对相同的数据进行修改。
>
> 在 row 模式下，bin-log 中可以不记录执行的 SQL 语句的上下文相关的信息，仅仅只需要记录那一条记录被修改了，修改成什么样了。所以 row 的日志内容会非常清楚的记录下每一行数据修改的细节，非常容易理解。而且不会出现某些特定情况下的存储过程或 function ，以及 trigger 的调用和触发无法被正确复制的问题。
>
> 在 row 模式下，所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容，比如有这样一条 update 语句
>
> ```
> update table1 set col1 = 0;
> ```
>
> 由于这条语句做了全表更新，没一行的数据都会被记录到binlog中，这样基于行的复制就会开销很大。
>
> 优点：几乎没有基于行的复制模式无法处理的场景
>
> 缺点：执行起来就像黑盒子，无法知道服务器正在做什么，因此出现问题时很难找到问题所在。某些情况下，例如找不到要修改的行时，基于行的复制可能会导致复制停止。



`mysql-bin.index`: 该文件用于记录磁盘上的二进制日志文件。这个文件的每一行包含了二进制文件的的文件名。MySQL依赖于这个文件，除非在这个文件中有记录，否则MySQL识别不了二进制日志文件。

`mysql-relay-bin-index`: 这个文件是中继日志的索引文件，和mysql-bin.index的作用类似。

`master.info`：这个文件用于保存备库连接到主库所需要的信息，格式为纯文本。此文件不能删除，否则备库在重启后无法连接到主库。这个文件用文本的方式记录了复制用户的密码，所以要注意这个文件的权限控制。

`relay-log.info`：这个文件包含了当前备库复制的二级制日志和中继日志坐标（例如，备库复制在主库上的位置），不能删除，否则在备库重启后将无法获知从哪里开始复制。



常用的复制结构

- 一主多备库
- 双主复制
- 主-主复制（其中一台设置为只读）
- 拥有备库的双主复制
- 环形复制（应尽量避免）
- 主库、分发主库以及备库
- 树或金字塔型（一个主库，2个备库，再下接4个备库，和二叉树一样）



复制过程中可能会碰到的问题

- 主库意外关闭
- 备库意外关闭
- 主库上的二进制日志损坏
- 备库上的中继日志损坏
- 二进制日志与InnoDB事务日志不同步
- 不唯一或未定义的服务器ID
- 过大的复制延迟
- 来自主库过大的包
- 受限制的带宽
- 磁盘空间不足

以上这些还只列出了一部分问题，更多的你可以详细上网去了解。总之这里面的问题太多，你需要十分小心。



复制时候需要注意很多东西，这里列几点总结建议：

- 使用Percona Toolkit中的pt-table-checksum以确定备库是主库的真实拷贝
- 监控复制以确定其正在运行并且没有落后于主库
- 理解复制的 异步本质，并且设计你的应用以避免或容忍从备库读取脏数据
- 在一个复制拓扑中不要写入超过一个服务器，把备库配置为只读，并降低权限以阻止对数据的改变。

