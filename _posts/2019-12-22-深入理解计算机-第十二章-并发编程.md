---
layout: page
title: 深入理解计算机 第十二章 并发编程
mermaid: false
---

# 第十二章 并发编程



## 基于进程并发

使用从父进程派生出一个子进程的方式来进行并发操作。

进程间有共享文件表，但是不共享用户地址空间。

- 避免不小心覆盖另一个进程的虚拟内存。
- 但是进程间共享信息变得困难，可以使用IPC机制进行通信



## I/O多路复用并发

使用select函数，要求内核挂起进程，只有在一个或者多个I/O事件发生后，才将控制程序返回给应用程序。

- 当集合{0, 4}中任意描述符准备好读时返回
- 当集合{1,2,7}中任意描述符准备好写时返回
- 如果在等待一个I/O事件发生时过了152.13秒，就超时

优点：

- 比基于进程的设计给了程序员更多的对程序行为的控制
- 运行在单一进程中，共享数据变得简单
- 调试更简单
- 事件驱动设计常常比基于进程的设计要高效的多。

缺点：

- 编码复杂
- 不能充分利用多核处理器



## 基于线程的并发

线程由内核自动调度，通过一个整数ID来识别线程。多个线程共享单一进程所有内容。

线程通过pthread_create函数来创建其他线程

```c
#include <pthread.h>
typedef void *(func)(void *);

int pthread_create(pthread_t *tid, pthread_attr_t *attr, func *f void *arg);
```

终止线程：

- 当顶层的线程例程返回时，线程会隐式的终止
- 通过调用pthread_exit函数，线程会显示的终止。如果主线程调用pthread_exit，它会等待所有其他对等线程终止，然后再终止主线程和整个进程，返回值为thread_return。
- 某个对等线程调用linux的exit函数，该函数终止进程以及所有与该进程相关的线程
- 另一个对等线程通过以当前线程ID作为参数调用pthread_cancel函数来终止当前线程。



**线程通过调用pthread_join函数等待其他线程终止，并回收资源。**

pthread_join函数会阻塞，直到线程终止，然后回收已终止线程占用的所有内存资源。



**线程通过调用pthread_detach函数被分离**

> 线程分离就是当线程被设置为分离状态后，线程结束时，它的资源会被系统自动的回收，而不再需要在其它线程中对其进行 pthread_join() 操作。
>
> 默认创建一个线程的时候，线程是 joinable 的。 joinable 状态的线程，必须在另一个线程中使用 pthread_join() 等待其结束，如果没有使用 pthread_join() 进行操作，这个线程就会变成”僵尸线程”。每个僵尸线程都会消耗一些系统资源，当有太多的僵尸线程的时候，可能会导致创建线程失败。
>
> 一般情况下建议使用分离线程，当然显示的调用等待线程结束也是需要的方式，根据自己情况来选择。







## 多线程的共享变量

### 线程的内存模型

线程独有的：线程上下文（线程ID、栈、栈指针、程序计数器、条件码和通用目的寄存器值）

线程共有的：进程上下文（用户虚拟地址(只读文件、读写数据、堆以及所有共享库代码和数据区域组成)，相同的打开文件集合）

### 变量映射到内存

- 全局变量：全局变量是定义在函数之外的变量，任何线程都可以引用。
- 本地自动变量：定义在函数内部但是没有static属性的变量。每个线程都有自己的一份本地变量的实例。
- 本地静态变量：定义在函数内部有static属性的变量。和全局变量一样。

### 共享变量

我们说一个变量是共享的，当且仅当它的一个实例被一个以上的线程引用。



## 用信号量同步线程

共享变量容易引入同步错误的可能性。这里引入经典的信号量方式来进行线程间的同步操作。

   P（S）：将信号量S的值减1，即S=S-1；
           如果S>0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。
    V（S）：将信号量S的值加1，即S=S+1；
           如果S>0，则该进程继续执行；否则释放队列中第一个等待信号量的进程。

 使用PV操作实现进程互斥时应该注意的是：

- （1）每个程序中用户实现互斥的P、V操作必须成对出现，先做P操作，进临界区，后做V操作，出临界区。若有多个分支，要认真检查其成对性。
- （2）P、V操作应分别紧靠临界区的头尾部，临界区的代码应尽可能短，不能有死循环。
- （3）互斥信号量的初值一般为1。



## 并发问题

- 线程安全
- 可重入性（线程安全的真子集，通常是访问各自的私有栈资源，不访问任何共享数据）
- 系统自带的函数有些不是线程安全的，尽量使用可重入版本
- 竞争
- 死锁



## 总结

并发程序是由时间上重叠的一组逻辑流组成的。这一章介绍了三种并发方式：进程、I/O多路复用和线程。

并发访问的同步问题是一个比较困难的问题。

这一章节针对如何创建多并发的程序提供了一些基本的思路和方法，也提出了一些并发带来的一些基本问题，并对如何解决也提供了一些思路和方法，基本上囊括了一个多并发的程序需要的基本知识点。