---
layout: page
title: 高性能MySQL 第六章 查询性能优化
mermaid: true
---

# 第六章 查询性能优化

**首先要明白为什么会查询慢**？

一个查询的生命周期大概是这样的：从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。

其中执行可以认为是生命周期中最重要的阶段，这其中包括了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序、分组等。

如果把一个查询看成一个任务，那么它还有很多子任务，网络传输，CPU计算，生成统计信息和执行计划、锁等待等操作，尤其是向底层存储引擎检索数据调用操作，这些调用需要在内存操作、CPU操作和内存不足时导致的I/O操作上消耗时间。

了解查询的生命周期，清楚查询的时间消耗情况对于优化查询有很大意义。



**优化数据的访问**

查询性能低下最基本原因就是访问的数据太多，因此每次查询前都要确认以下2点：

- 确认应用程序是否在检索大量超过需要的数据。
- 确认MySQL服务器层是否在分析大量超过需要的数据行。



我们通常会犯的问题：

- 查询不需要的记录
- 多表关联时返回全部列
- 总是取出全部列
- 重复查询相同的数据



衡量查询开销的三个标准

- 响应时间
- 扫描行数
- 返回的行数

响应时间很重要，每个公司对于慢查询的时间都不一样，比如MySQL默认`long_query_time=10`，即超过10s就会记录慢查询日志，这个可以自行配置，响应时间应该是首要关注的。

理想情况下扫描行数和返回行数应该是相同的，则说明查询是很好的，但这是很难的。



MySQL使用如下三种方式应用where查询：

- 在索引中使用where条件来过滤不匹配的记录。这是在存储引擎层完成的东西。
- 使用索引覆盖扫描（在Extra列中出现了Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无须再回表查询记录。
- 从数据表中返回数据，然后过滤不满足条件的记录（在Extra列中出现Using where）。这在MySQL服务器层完成，MySQL需要先从数据表读出记录然后过滤。



**重构查询**

复杂查询变成多个简单查询，一个大的SQL语句一次完成的话，则可能需要一次锁住很多数据，占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。



**分解关联查询**

在多表联查时候，尽量分开多个表多次查询完成：

- 让缓存的效率更高
- 将查询分解后，执行单个查询可以减少锁的竞争
- 在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展
- 查询本身的效率也会有所提升
- 可以减少冗余记录的查询
- 更进一步，这样做相当于在应用中实现了哈希关联，而不是使用MySQL的嵌套循环关联。



MySQL执行一条查询的过程如下：

```flow
st=>start: 客户端
op=>operation: 连接器
cond=>condition: 是否在缓存
sub=>operation: 分析器
sub2=>operation: 优化器
sub3=>operation: 执行器
e=>end
e2=>end: 存储引擎

st->op->cond
cond(yes)->op
cond(no)->sub->sub2->sub3->e2
```



我们了解查询过程后就能更好的来针对性的进行优化。接下来我们将逐步分析下一些重要的步骤点。

mysql客户端与服务器通信协议

> MySQL客户端和服务器之间的通信协议是“半双工”的，这意味着，在任何时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据。
>
> 好处是这样通信简单快速。
>
> 坏处是没法进行流量控制，必须接收/发送完整个数据后才能进入下一个状态。

查询缓存

> 开启MySQL的缓存如下所示
>
> `set global query_cache_type = ON;     --开启查询缓存`
>
> MySQL会对SELECT语句进行大小写敏感的hash缓存，如果缓存打开，则在查询时候如果有对应缓存则会直接取缓存结果。
>
> 但是一般生产环境建议是吧这个缓存关掉的。具体原因大家可以自行深入了解。

查询优化处理

> 分析器和优化器就是进行查询优化处理的。MySQL通过关键字将SQL语句进行解析，生成一颗对应的“解析树”，然后MySQL将使用语法规则验证和解析查询。
>
> 语法合格了则优化器就会将其转化成执行计划，一个查询可以有很多种执行方式，优化器就是在这多种方式中找到最佳的执行计划。
>
> MySQL优化器它可以很好的帮助我们选择最优的执行方案，比如我们常用的联合索引，你查询时候只要按照联合索引的字段顺序查询，你就可以用到这个联合索引，但是你在写SQL语句时候并不一定要按字段顺序来，只要你有联合索引的第一个字段，优化器就会给你自动排序成联合索引使用。
>
> 但也有可能选择的执行计划不是最优的，它是一个非常复杂的结构，这里就不详细说明了，详细可以查看书中的6.4.2节的内容。有一句话也得要记着”不要自以为比优化器更聪明“。

查询执行引擎

