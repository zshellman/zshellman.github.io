# 深入理解计算机系统



## 第10章  系统级I/O

为什么要学I/O?

两个进程之间用什么方式交流数据？暂时能想到的就是文件和网络，文件读写和网络通信(套接字socket)都是I/O里面的，所以一个进程想要和系统或者其他进程进行交流，那就必须得用到I/O，这就是我们为什么学它。



Linux中，所有的I/O设备都被模型化为文件，所有的输入和输出都被当做对相应文件的读和写来执行。这种将设备优雅的映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为Unix I/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行。

- **打开文件**：应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I／O设备时，内核会返回一个非负整数，叫做**描述符**，它在后续对此文件的所有操作中标识这个文件。应用程序只需要记住这个描述符即可。

- Linux shell创建每个进程开始时都有三个打开的文件，**标准输入（描述符为0），标准输出（描述符为为1），标准错误（描述符为为2）**。

- **改变当前的文件位置**：对于每个打开的文件，内核保持一个文件位置k,初始为0，这个文件位置是从文件开头起始的字节偏移量，应用程序能够通过执行**seek**操作，显式地设置文件的当前位置为k。

- **读写文件**：一个读操作就是从文件复制n > 0个字节到内存，从当前文件位置k开始，然后将k增加到k + n。给定一个大小为m字节的文件，当k >= m时执行读操作会触发一个称为end-of-file(EOF)的条件。应用程序能检测到这个条件。但是在文件结尾处并没有明确的”EOF符号“

  类似的，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。

- **关闭文件**: 当应用完成了对文件的访问之后，它就通知内核，关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。



## 文件

- 普通文件包含任意数据，应用程序通常要区分文本文件和二进制文件，但对内核来说都一样。
- 目录是包含一组连接的文件，每个链接都将一个文件名映射到一个文件，这个文件可能是另一个目录。
- 套接字（socket）是用来与另一个进程进行跨网络通信的文件

文件路径**绝对路径名**和**相对路径名**这个就不用多说了。



## 打开和关闭文件

和你接触到的所有高级语言一样，Linux下通过open喊出来打开一个已存在的文件或者创建新文件：

```c
int open(char *filename, int flags, mode_t mode);
```

open函数将filename转换为一个文件描述符（初始时候是3），返回的描述符是当前进程中没有打开的最小描述符，比如你初始打开一个文件那么返回就是3，再打开一个文件就是4了，以此类推。

flags参数指明如何访问这个参数

- `O_RDONLY`: 只读
- `O_WRONLY`: 只写
- `O_RDWR`:可读可写

mode参数指定新文件的访问权限。跟linux下用户对文件的访问权限一致。

进程通过close函数关闭一个打开的文件

```c
int close(int fd)
```



## 读写文件

程序通过下面两个函数来进行读和写入文件的。

```c
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t n);
ssize_t write(int fd, const void *buf, size_t n);
```

`read() `返回：若成功则为读的字节数，若EOF则为0，出错为-1

`write()`返回：若成功则为写的字节数，若出错则为-1

read函数从描述符fd的当前文件位置复制最多n个字节到内存位置buf。

write函数从内存位置buf赋值最多n个字节到描述符fd的当前文件位置。

通过调用lseek函数，应用程序能够显示的修改当前文件的位置。

在某些情况下，read和write传送的字节比应用程序要求的要少。但者并不表示有错误。

- 读时遇到EOF。简单说就是文件只有20字节，你用50字节去读，这时read就只返回20，此后再读将返回不足值0来发出EOF信号。
- 从终端读取文本行。在终端读取时候默认是读一行的，那么read函数返回的不足值等于文本行大小
- 读和写网络套接字。网络传输信息时候网络延迟会引起read和write返回不足值。
- 读磁盘时候也会遇到不足值。



## 用RIO包健壮的读写

使用RIO包它可以自动为你处理上文中的不足值。

RIO提供两类不同的函数：

- 无缓冲的输入输出函数

  ```c
  #include "csapp.h"
  ssize_t rio_readn(int fd, void *usrbuf, size_t n);
  ssize_t rio_writen(int fd, void *usrbuf, size_t n);
  ```

  `rio_readn`函数从描述符fd的当前文件位置复制最多n个字节到内存位置usrbuf。

  `rio_writen`函数从内存位置usrbuf赋值最多n个字节到描述符fd的当前文件位置。

- 带缓冲的输入函数

  ```c
  #include "csapp.h"
  void rio_readinitb(rio_t *rp, int fd);
  ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen);
  ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n);
  ```

  rio_readlineb它从一个内部读缓冲区中复制一个文本行，当缓冲区变空时，会自动调用read重新填满缓冲区。

  rio_readnb可以读取一个既包含文本同时包含二进制数据的文件。



## 读取目录

用readdir函数读取目录内容：

```c
#include <sys/types.h>
#include <dirent.h>
DIR *opendir(const char *name);
```

函数opendir以路径名为参数，返回指向目录流的指针，流是对条目有序列表的抽象，这里是指目录项的列表。

```c
#include <dirent.h>
struct dirent *readdir(DIR *dirp)
```

每次对readdir的调用返回的都是指向流dirp中下一个目录项的指针，如果没有更多目录项则返回NULL

函数closedir关闭流并释放其所有的资源。

```c
#include <dirent.h>
int closedir(DIR *dirp);
```



## 共享文件

内核用相关的数据结构来表示打开的文件:

- 描述符表: 每个进程都有它独立述符表，每个打开的描述符表项指向文件表中的一个表项。
- 文件表: 打开文件的集合由一张文件表来表示，所有的进程共享这张表。每个文件表的表项包括当前的文件位置，引用计数(即当前指向该表项的描述符表项数)，以及一个指向v-node表中对应表项的指针。关闭一个文件描述符会减少相应的文件表表项中的引用计数。内核不会删除这个文件表表项，直到它的引用计数为零.
- v-node表: 所有进程共享v-node表。每个表项包含相应打开文件的属性信息，包括stat结构的的大部分信息，诸如st_mode和st_size成员.





## I/O重定向

Linux shell 提供了I/O重定向操作符，允许用户将磁盘文件和标准输入输出联系起来，如：

```
ls > foo.txt
```

上面命令即将ls命令的输出重定向到磁盘文件foo.txt。

I/O重定向使用如下函数：

```c
#include <unistd.h>
int dup2(int oldfd, int newfd);
```

dup2函数赋值描述符表表项oldfd到描述符表项newfd，覆盖描述符表newfd以前的内容。如果newfd已经打开了，dup2会在赋值oldfd之前关闭newfd。



## 标准I/O

c语言定义的标准I/O库，为程序员提供了Unix I/O的较高级别的替代。提供打开和关闭文件的函数(fopen和fclose)、读和写字节的函数(fread和fwrite)、读和写字符串的函数(fgets和fputs)。以及复杂的格式化I/O函数(scanf和printf)。



## 总结

如何使用？

- 尽量使用标准I/O
- 不要使用scanf或rio_readlinb来读二进制文件
- 对网络套接字I/O使用RIO函数

本章我们学到I/O的基本概念，打开关闭文件，文件描述符，共享文件，I/O重定向是如何操作的。使用原始的read，write函数会有short counts的奇特行为，可以通过RIO包来正确处理。

总之，本章就是一个基础性的介绍，主要目的是让读者明白系统是如何操作文件的，以及会有什么问题，然后还做出了些优化包RIO，为下一章网络编程打下基础。

