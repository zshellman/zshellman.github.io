# 敏捷软件开发第6章

本章主要是借一个保龄球计分程序的设计，来让读者体验什么是结对编程，什么是测试驱动开发以及开发重构的重要性。让读者深度体验了一次XP的编程实践。

这里书上的内容我就不再重复，有兴趣的朋友可以去详细查看书籍。我从中主要想说两点，一是测试驱动开发，二是代码的重构。



## 测试驱动开发

一般我们说的测试驱动开发都是TDD。

> TDD 是敏捷开发中的一项核心实践和技术，也是一种设计方法论。TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。TDD 是 XP（Extreme Programming）的核心实践。它的主要推动者是 Kent Beck。

那么我们不禁要问，为什么要使用这种方式？

好，我们来对比一下普通流程和测试驱动开发的流程。

**普通开发流程**

> - 1、拿到需求，大概清楚了后就开始动手开发
> - 2、发现细节不明确，找产品确认，然后重复当前步骤n次
> - 3、写完就准备运行起来看看，发现，咦，不出所料，运行有问题，然后调试
> - 4、好了，终于搞定可以正常跑起来了，手动测试下主体流程，没问题，然后丢给测试
> - 5、隔天测试已经不想跟你话，向你丢了一堆bug过来
> - 6、你加班调试修改，一顿猛操作，搞定，然后继续重复5-6步直至上线

最后你发现，上线的代码跟坨屎一样，想重构都有心无力，一动代码也许就有意想不到的bug出来搞死你。

**再看看测试驱动开发**

> - 1、拿到需求，理清各个需求点
> - 2、针对每个需求点写测试代码，只关注输入输出的结果是否符合要求
> - 3、根据测试代码去写实际的代码逻辑
> - 4、重构，用尽量简洁的代码重写逻辑
> - 5、调用测试用例，检测错误问题，修复，然后重复4,5步骤直至开发完
> - 6、转测试，基本没问题，有也是小问题，修复，再重复4,5步骤转测试
> - 7、上线，代码整洁且测试用例齐全，不会出现上线后再出问题又来加班情况

所以我们可以明显看到两种方式的不同，也会发现测试驱动开发真的是完胜传统开发流程。

这里总结下好处：

- 写测试用例过程你就会明确需求细节，不会再开发到一半然后跑去跟产品沟通细节情况
- 需求有变更时候更容易修改
- bug数量直线下降，未知bug基本不会出现，不用加班改bug了！

所以我在此强烈建议日常开发一定要使用测试驱动开发的方式，为你好也为他好。



## 重构

重构是一个老生长谈的话题了，这个话题要说的话那是需要一本书了，我这里就简单抛砖引玉一下，有兴趣的建议去看看《重构：改善既有代码的设计》这本经典书。

好了，言归正传，我们为什么要重构？

比如上文中我们说到的你使用普通开发流程完成需求上线后，你会发现你的代码就是一坨屎，后继者再来在你这个代码上进行需求新增，修改bug，都会在心里问候一遍写代码的人。说不得你自己还会问候到你自己头上。

好的代码一定是语义清晰，逻辑简单，功能单一的。在敏捷开发第6章里面，你会发现到最后作者实现的代码清晰明了，跟伪代码几乎一模一样，你一看就知道这段逻辑是在做什么事，这就是好的代码。

那么我们什么时候重构呢？有以下几个原则：

- 三次法则：同样的事做三次，就代表你需求重构这一块代码了
- 添加功能时重构：如果现有设计对添加功能有妨碍，先完成重构再添加功能
- 修改bug时重构：如果现有设计对查找bug有妨碍，先重构在查找bug
- codereview时重构：别人如果看不懂，那就不是合适的代码

最后再说一句，反对专门拨出时间进行重构。在我看来，重构本来就不是一件「特别拨出时间做」的事情，重构应该随时随地进行。你不应该为重构而重构，你之所以重构，是因为你想做别的什么事，而重构可以帮助你把那些事做好。

