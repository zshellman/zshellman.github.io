# 敏捷软件开发 第10-12章

这三章主要讲了替换原则、依赖倒置、接口隔离这三个程序开发的基本原则。



## 替换原则（LSP）

替换原则可以做如下解释：

> **子类型必须能够替换掉他们的基类型。**

需要如下替换性质：

> 如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有变化，那么类型T2是类型T1的子类型。

反过来父类是不能替换子类的。



替换的重点是继承，而继承是面向对象三大特性之一，它有以下特点：

- 代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性
- 提高代码的重用性
- 子类可以形似父类
- 提高代码的可扩展性

继承有它的优点，但是也有一些致命的缺点：

- 继承具有侵入性，只要子类继承了父类，那么子类必须拥有父类的所有属性和方法
- 降低了代码的灵活性
- 增强了耦合性。当父类中发生方法，属性的修改时需要考虑子类是否修改，而且在缺乏规范的情况下，还可能发生大段的代码重构



需要注意的一点是OOD(面向对象设计)中IS-A关系是就行为方式而言的。作者在这里用了一个正方式是不是长方形的例子来解释这一点。

> 数学上我们把正方形说成是特殊的长方形，但是在程序上你如果让正方形继承长方形，那就会出问题，比如
>
> ```
> void g(Rectangle& r)
> {
>     r.setWidth(5);
>     r.setHeight(4);
>     assert(r.Area() == 20);
> }
> ```
>
> 上面这个代码就是求长方形面积的测试用例，但是如果用正方形来替换掉长方形那这个测试就会失败。
>
> 因此我们要明白里氏替换原则与通常的数学法则和生活尝试有不可混淆的区别。

LSP是使OCP成为可能的主要原则之一。正式子类型的可替换性才使得使用基类类型的模块在无需修改的情况下就可以扩展。



## 依赖倒置原则（DIP）

传统的过程性系统的设计办法倾向于使用高层次的模块依赖于低层次的模块，抽象层次依赖于具体层次。倒转原则是把这个错误的依赖关系倒转过来。

倒转原则有一下特点：

- 高层模块不应该依赖于底层模块，二者都应该依赖于抽象。
- 抽象不应该依赖于细节，细节应该依赖于抽象。

依赖抽象有什么好处呢？以java举例，java中有list、map等接口，那么我们在写代码时候就可以如下所示：

```
List list1 = new ArrayList();
List list2 = new LinkedList();
```

这样我们就可以不用关心具体的实例是什么，而使用统一的变量来操作它们。

面向抽象编程是面向对象编程所应遵循的基本原则之一。我们应该是细节依赖抽象，下层依赖上层，这样才是一个好的结构。依赖倒置原则对于创建可重用的框架来说是必须的。抽象和细节彼此隔离，代码会非常容易维护。



## 接口隔离原则（ISP）

接口隔离原则讲的是：使用多个专门的接口比使用单一的总接口要好。

过于臃肿的接口是对接口的污染，每一个接口代表一个角色，实现一个接口的对象，在它的整个生命周期中都扮演着这个角色，因此将角色区分清楚是系统设计的一个重要工作。

通常建议一个接口最好是单一的，说个例子：

比如我定义4个接口吃、喝、跑、飞等行为，那么这种单一接口的好处就体现在我可以随机组合，比如我定义个动物类就可以实现吃、喝、跑的接口，我定义一个鸟类型就可以4个接口都实现，这样就可以动态的添加行为。而如果你直接定义一个接口里面含有这4种行为，那狗类型就不能继承这个类了，因为它不能飞。这就是接口隔离原则的好处。



注意：
- 接口尽量小，但是要有限度。如果接口过于小，则会造成接口数量过多的问题，使设计复杂化；接口也不能太大，那就违背了接口隔离原则。所以一定要适度。

- 只有专注地为一个类提供定制服务，才能建立最小的依赖关系；

- 提高内聚，减少对外交互。使接口用最少的方法去完成更多的事情。