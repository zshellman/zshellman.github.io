# 敏捷软件开发第13~17章

这几章主要谢了几个设计模式，我们来简单了解下。



## COMMAND模式和ACTIVE OBJECT模式

COMMAND模式即命令模式：

> 将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。

命令模式是对命令的封装。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。

每一个命令都是一个操作，请求的一方发出请求要求执行一个操作，接收的一方收到请求，并执行操作。

命令模式有以下有点：

- 命令模式使新的命令很容易地被加入到系统里
- 允许接受请求的一方决定是否要否决请求
- 能比较容易的设计一个命令队列
- 可以容易地实现对请求的Undo和Redo
- 在需要的情况下，可以较容易地将命令记入日志

命令模式结构图如下：

![](image/COMMAND.png)



**Active Object模式**是一种异步编程模式。它通过对方法的调用与方法的执行进行解耦来提高并发性。若以任务的概念来说，Active Object模式的核心则是它允许任务的提交（相当于对异步方法的调用）和任务的执行（相当于异步方法的真正执行）分离。



## TEMPLATE METHOD模式和STRATEGY模式

TEMPLATE METHOD即模板方法模式：

> 定义一个操作中的算法骨架，而将一些操作步骤延迟到子类中

模板方法使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤



STRATEGY模式即策略模式：

> 定义一些列算法，并将每一个算法封装起来，使算法本身和使用算法的客户端分割开来，相互独立

比如超市促销，使用各种策略，这时候就可以用到策略模式。



## FACADE模式和MEDIATOR模式

**facade模式：**

> 为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用

何时使用facade模式？

- 为一个复杂的子系统提供一个简单接口

  > 子系统很复杂，这时候使用facade模式可以使得子系统更具可复用性。

- 子系统的独立性

  > 引入facade模式将一个子系统和它的客户端以及其他子系统隔离开，可以提供子系统的独立性和可移植性

- 层次话结构

  > 在构建一个层次化的系统时，可以使用facade模式定义系统中每一层的入口。



**mediator模式即中介者模式**

> 用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示的相互引用，从而使其耦合松散，而且可以独立改变他们之间的交互

比如联合国就是典型的中介者模式的应用，各个国家之间可以不用相互了解，互相通知都可以通过联合国机构进行通信。

中介者模式切记不要乱用，因为中介者模式优点是把所有对象之间的联系通过一个中间人去完成，而缺点也是这个，这就意味着这个中间人的责任太大，一旦中间人挂了，所有人都通信不了了。



## SINGLETON模式和MONOSTATE模式

单例模式想必大家都已经很熟悉了，简单的说就是整个系统中只有一个该对象的实例。例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；



monostate模式就有点神奇了：

> 把类的属性全变成静态变量，这样所有的实例对象都会共用一个属性变量

我们来简单说一下这种模式的优缺点：

优点：

- 透明性：用户不必知道使用的对象是Monostate对象
- 可派生性：可以继承，共同享有静态变量
- 多态性：用父类去指向子类，实现多态。

缺点：

- 不可转换性
- 效率问题：是对象就会导致许多的创建和销毁的开销
- 内存占用：静态变量即使不使用也占内存
- 平台局限性：不可用于所有的平台



## NULL OBJECT模式

这是个很少使用的模式，在编程中我们经常会碰到null对象的问题，我们每次都需要进行判断才能进行接下来的逻辑运行。而这个对象就是用来解决这个问题的。

我们在函数返回的时候可以返回一个空对象，空对象是一个没有实质性内容的对象，但他并不为null。你可以把空对象理解为一个空箱子，这个物品还是存在的，只不过仅仅是一个壳，没有实质性的东西。

这样我们在外部就不需要判断null这种情况了，程序也不会崩溃，有兴趣的同学可以自行上网了解下。