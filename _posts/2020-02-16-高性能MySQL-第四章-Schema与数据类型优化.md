---
layout: page
title: 高性能MySQL 第四章 Schema与数据类型优化
mermaid: false
---

# 第四章 Schema与数据类型优化

数据类型的选择和优化

- 更小的通常更好：尽量使用可以正确存储数据的最小数据类型
- 简单就好：简单数据类型的操作通常需要更少的CPU周期，比如整型性能高于字符
- 尽量避免null

在整数手中，int(1)和int(11)是没有区别的，里面的数字是控制“显示长度”的，结合ZEROFILL，mysql会自动在不满足位数的数字之前填充0用来满足位数，

例如你设置了一个int(11)，这时候你插入一个1，则mysql在客户端显示时候会在1的前面填充10个0。

```
mysql> CREATE TABLE d2(c1 BIGINT(5) ZEROFILL, c2 BIGINT ZEROFILL, 
    -> c3 BIGINT(30) ZEROFILL);
Query OK, 0 rows affected (0.67 sec)
mysql> INSERT INTO d2 VALUES (1, 1, 1);
Query OK, 1 row affected (0.06 sec)
mysql> INSERT INTO d2 VALUES (123456, 123456, 123456);
Query OK, 1 row affected (0.08 sec)
mysql> SELECT * FROM d2;
+--------+----------------------+--------------------------------+
| c1     | c2                   | c3                             |
+--------+----------------------+--------------------------------+
|  00001 | 00000000000000000001 | 000000000000000000000000000001 |
| 123456 | 00000000000000123456 | 000000000000000000000000123456 |
+--------+----------------------+--------------------------------+
2 rows in set (0.00 sec)
```

当你没有使用ZEROFILL时候，mysql的客户端是不会显示填充0的，但是其他非mysql的客户端是有可能进行显示的。

varchar占用存储小一些，char由于是固定长度，所以占用空间大一些。

对于字符串，随机的字符串有以下要注意的：

![](..\img\mysql_1.png)





数据库的范式

- 第一范式(1NF)，字段的原子性，字段必须不可再次分解
- 第二范式(2NF)，消除部分依赖，第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关(主要针对联合主键而言)
- 第三范式(3NF)，消除传递依赖：非主键字段不能相互依赖



反范式

故名思义，跟范式所要求的正好相反，在反范式的设计模式，我们可以允许适当的数据的冗余，用这个冗余去取操作数据时间的缩短。**也就是用空间来换取时间,把数据冗余在多个表中，当查询时可以减少或者是避免表之间的关联。**

反范式的利弊：

优点：

1. 查询时可以减少表的关联；
2. 可以更好的进行索引优化；

缺点：

1. 存在数据冗余以及数据维护异常；
2. 对数据的修改需要更多的成本；



schema设计中的陷阱

- 太多的列
- 太多的关联
- 全能的枚举
- 变相的枚举



缓存表/汇总表 可以用来提升性能，比如在同一张表里面保存衍生的冗余数据，或者创建一张完全独立的汇总表或缓存表。

