# 第五章 创建高性能的索引



## 索引的类型

**B-Tree索引**

大多数说到的索引都是指B-Tree索引，它使用B-Tree数据结构来存储数据。实际上很多存储引擎使用的是B+Tree，InnoDB使用的就是B+Tree。

B-Tree是一种n叉树的结构，所有值都是按顺序存储，并且每一个叶子页到根的距离相同。

B-Tree适用于全键值，键值范围或键前缀查找。

B-Tree索引的限制：

- 如果不是按照索引的最左列开始查找，则无法使用索引
- 不能跳过索引中的列
- 如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引



**哈希索引**

- 在MySQL中只有Memory引擎显示支持哈希索引。

- 哈希索引不是按顺序排列的，所以无法用于排序。

- 哈希索引不支持部分索引列匹配查找，比如你建立一个（A,B）2个列的索引，如果只查询A，则无法使用该索引。

- 哈希索引只支持等值比较查询，不支持任何范围查询
- 没有哈希冲突情况下访问哈希索引很快，有冲突时候存储引擎必须遍历链表中所有行指针。
- 如果哈希冲突很多，则维护哈希索引的代价很大。



**空间数据索引（R-Tree）**

MyISAM表支持空间索引，可以用做地理数据存储。MySQL的GIS支持并不完善，GIS做的比较好的是PostgreSQL和PostGIS。

**全文索引**

全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值，这个我感觉用Elaticsearch会比较好。



## 索引的优点

- 索引大大减少了服务器需要扫描的数据量
- 索引可以帮助服务器避免排序和临时表
- 索引可以将随机I/O变为顺序I/O

对于小表，大部分情况下简单的全表扫描更高效。对于中到大型表，索引就非常有效。但对于特大型的表，建立和使用索引的代价将随之增长。对于TB级别的数据，定位单条记录的意义不大。

索引将相关的记录放到一起则获得一星，如果索引中的数据顺序和查找中的排列顺序一致则获得二星，如果索引中的列包含了查询中所需要的全部列则获得“三星”。





## 高性能索引策略

独立的列：索引列不能是表达式的一部分，也不能是函数的参数；

索引的区分度，比如我们来计算test_string这个字段的索引值：

```
select count(distinct test_string)/count(*) from test
```

针对不通前缀索引：

```
select 
    count(distinct left(test_string, 3))/count(*) as sel3,
    count(distinct left(test_string, 4))/count(*) as sel4,
    count(distinct left(test_string, 5))/count(*) as sel5,
    count(distinct left(test_string, 6))/count(*) as sel6,
    count(distinct left(test_string, 7))/count(*) as sel7
 from test
```

这样得出来的数字，哪个与1最接近，则最好。



在MySQL5.0和更新的版本中，查询多列时候mysql会同时使用这多个列的索引尽心扫描，并将结果进行合并。如果你在explain  sql语句时候在Extra中看到有`Using union`时候就要注意了。

多列索引：

- 当服务器对多个索引做相交操作时候（通常有多个AND条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的多个索引。
- 当服务器要对多个索引联合操作时（通常有多个OR条件），通常需要耗费大量CPU和内存资源在算法的缓存、排序和合并上。特别是当其中有些索引选择不高，需要合并扫描返回的大量数据的时候。
- 更重要的是，优化器不会把这些计算到“查询成本”（cost）中，优化器只关心随机页面读取。这会使得查询的成本被“低估”，导致该执行计划还不如走全表扫描。



选择合适的索引列顺序有一个经验法则：将选择性最高的列放到索引最前列。当然这不是一个放之四海而皆准的法则，场景不同则选择不同，考虑问题要考虑全面，分组和排序，避免随机I/O都是对一个索引来说也很重要的。



**聚簇索引**

> 聚簇索引是把数据放在了索引里面，次级索引指向主键索引。
>
> - 1、主键索引，既存储索引值，又在叶子中存储行的数据
> - 2、如果没有主键，则会Unique key做主键
> - 3、如果没有unique，则系统生成一个内部的rowid做主键
> - 4、像innodb中，主键的索引结构中，即存储了主键值，又储存了行数据，这种结构成为“聚簇索引”
>
> 优势：
>
> - 数据访问更快，根据主键查询条目比较少时，不用回行（数据就在主键节点下）
> - 可以把相关数据保存在一起。
> - 使用覆盖索引扫描查询可以直接使用页节点中的主键值
>
> 劣势：
>
> - 如果碰到不规则数据插入时，造成索引频繁的页分裂
> - 更新聚簇索引代价很高
> - 二级索引（非聚簇索引）可能比想象的要大

**覆盖索引**

> 如果一个索引包含所有需要查询的字段的值，我们就称之为“覆盖索引”。